# ISE lab4

### 221900073 孙佳琪



##### 程序所实现的功能

是在词法分析、语法分析、语义分析和中间 代码生成程序的基础上，将C源代码翻译为MIPS32指令序列（可以包含伪指令），并在 SPIM Simulator上运行。

##### 如何被编译

1.  make
2. ./parser 测试文件 输出文件

##### 个性化的内容

​	借鉴实验指导中介绍的局部寄存器分配，事先将整段代码分拆成一个个基本块，于是将结构体定义如下：

```c
struct BasicBlock {
    int id;
    InterCodes* first;
    InterCodes* last;
    BasicBlock* prev;
    BasicBlock* next;
    BasicBlocks* predecessor;
    BasicBlocks* successor;
};

struct BasicBlocks {
    BasicBlock* block;
    BasicBlocks* next;
};

struct EntryList {
    BasicBlock* entry;
    BasicBlock* exit;
    int blocknum;
    EntryList* next;
};
```

​	

​	具体的创建基本块、控制流图以及活跃变量分析的过程过程在mips.c当中，先进行一些初始化，将语义分析得到的符号表中的每一个符号都初始化一个相应的operand值。之后便是从root节点开始逐个进行分析和生成。

​	**`buildBasicBlocks()`**: 主要功能是将中间代码（Intermediate Code）分解成一系列的基本块（Basic Blocks）。基本块是控制流图（CFG）中的基本单元，它包含了一系列顺序执行的指令，这些指令之间没有跳转指令（如条件分支、函数调用返回等）。从第一条指令开始遍历中间代码链表。检查当前指令的种类（`kind`），如果遇到函数定义（`FUNCTION`）、标签（`LABEL`）、返回（`RETURN`）、条件跳转（`IF`）或无条件跳转（`GOTO`）等指令，则表示当前基本块结束，需要创建一个新的基本块。

​	**`buildFlow()`**: 主要功能是构建控制流图（CFG），它描述了程序中各个基本块之间的跳转关系。从流图的入口基本块开始，遍历每个基本块。如果当前基本块包含函数定义（`FUNCTION`），则为该函数创建一个新的入口和出口节点，并建立相应的前驱和后继关系。对于每个基本块，根据其最后一个指令的种类（如返回、条件跳转、无条件跳转等），确定其后继基本块，并建立相应的前驱和后继关系。对于条件跳转（`IF`），需要找到跳转目标标签对应的基本块，并建立从当前基本块到目标基本块的跳转关系。对于无条件跳转（`GOTO`），同样需要找到跳转目标标签对应的基本块，并建立跳转关系。最后更新流图的入口和出口节点，将函数入口基本块的后继设置为实际的第一个执行基本块。将函数出口基本块的前驱设置为最后一个执行基本块。

​	**`liveVariables()`**: 主要功能是实现活跃变量分析，函数首先获取控制流图（CFG）中的入口点列表 `entryhead`，并遍历每个基本块（Basic Block）。对于每个基本块，函数分配两个布尔型二维数组 `out` 和 `in`，分别用于存储每个基本块的输出和输入活跃变量集合。并根据实验指导中的内容![image-20241230114203338](C:\Users\sjq\Desktop\college\编译原理\实验\lab4\ISE lab3\image-20241230114203338.png)

​	使用迭代方法计算每个基本块的活跃变量集合，对于每个基本块，函数首先初始化输出活跃变量集合 `out`，然后，函数遍历基本块的后继节点，将它们的输入活跃变量集合合并到当前基本块的输出活跃变量集合中。接着，函数遍历基本块中的每条指令，根据指令中使用和定义的变量更新输入活跃变量集合 `in`。函数检查更新后的 `in` 集合是否与之前的 `in` 集合不同，如果有变化，则标记 `change` 为 `true` 并继续迭代。在处理完所有基本块后，函数释放之前分配的 `out` 和 `in` 数组所占用的内存。

​	生成具体指令的函数为**`MIPS(const char* fielname)`**,将中间代码中的各种操作转换成 MIPS 汇编语言，根据中间代码的种类`kind`实现各种操作，例如：处理`kind`为`FUNCTION`的中间代码时，生成函数入口点和栈帧设置代码，每次函数调用时，都需要为返回地址和局部变量分配栈空间，并保存旧的帧指针；处理`kind`为`ASSIGN`的中间代码时，针对不同情况，普通赋值（`NORMAL`）、获取地址（`GETADDR`）、获取值（`GETVAL`）、设置值（`SETVAL`）和复制（`COPY`），根据左值和右值的类型（变量、常量等），生成相应的加载和存储指令；处理`kind`为`ARG`的中间代码时，将函数参数存储到栈上，为函数调用做准备；处理`kind`为`IF`的中间代码时，从中间代码中提取条件表达式的两个操作数和跳转目标，然后计算偏移量并加载操作数，最后根据关系操作符（`relop`）的类型，生成相应的 MIPS 条件分支指令（`beq`、`bne`、`bgt`、`blt`、`bge`、`ble`）；处理`kind`为`RETURN`的中间代码时，从中间代码中提取返回值操作数，再计算偏移量并加载返回值，最后使用 `addi` 和 `lw` 指令恢复栈指针（`$sp`）和帧指针（`$fp`）到函数调用前的值，使用 `jr` 指令跳转到返回地址（存储在寄存器 `$ra` 中），完成函数的返回。

